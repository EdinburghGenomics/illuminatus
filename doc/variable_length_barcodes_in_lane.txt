When Illuminatus was designed we explicitly decided not to support variable-length barcodes in
one lane. The old pipeline did all sorts of things to make this possible - it split the sample
sheet and then combined the various reports and outputs back together. It worked but was very
hard to follow.

A related feature was to skip demultiplexing while keeping the barcode in the header. If you
tell bcl2fastq to ignore the index reads then it will output a single FASTQ file (or pair of
files) but the index sequence will be discarded - ie. not in the header at all. If instead
you demultiplex with a single dummy barcode (can be NNNNNNNN but it doesn't have to be) then
merge the Unassigned reads back into this file you end up with the same result but now you
have all the barcodes in the header. The problem here was that concatenating the .gz files
from bcl2fastq did not produce a valid .gz file (possibly due to file size or maybe due to
some formatting quirk). Thus the FASTQ files were unpacked, joined, and re-packed which for
a full lane of NovaSeq takes many days (though pigz+lustre can help us here). I suspect that
re-packing the smaller file (the reads assigned to the dummy barcode) then appending the
zipped Unassigned file to it will work and be much faster.

To address both of these the 'correct' approach is to fix bcl2fastq. I reckon a copetent
C++ coder could do it in about a month. This is less time than it would take me to implement
the sample sheet splitting approach but more time than it would take to re-implement the
"demultiplex on dummy and re-merge".

For the sample sheet splitting we have the idea of adding the adapter backbone to the index
in the reagent labels in Clarity. Then I guess if we have a barcode like this:

ATCGATCG

We'll replace it with one like this:

ATCGATCG[AA]-[AAAAAAAAAA], or equivalently ATCGATCGAA-AAAAAAAAAA [8,0] which encodes the same info.
The A's will be the adapter backbone.

We still assume all barcodes in a pool are the same length so the collision check at that point
is unchanged and uses the real barcode.
When clustering a lane and making a sample sheet, the code will retrieve all barcodes (as it does
already) then work out the longest "real" length of all the barcodes found and prune everything to
that length. This bit is fairly simple. However it should be noted that various bits of code have
baked-in assumptions about the format of barcodes, so these will have to be tracked down and fixed
before anything is changed in the LIMS.
Also I don't know if we can edit or clear out the barcodes in the system? If not, we have the potential
for confusing the lab. So we need to tread carefully.

It really would be easier to fix bcl2fastq.

For the fake demultiplex and merge, what I would need is:

1) The correct sample sheet needs to be generated by the LIMS.

2) The situation is recognised in the bcl2fastq preprocessor, either as a special case or applied
to all non-barcoded lanes. Basemask etc. is correctly generated.

3) The postprocessor step joins the files as in the old days

4) The reporting gets a load of special cases, since the Stats.json will now think all the reads were
in the unassigned whereas the QC will relate to the sample.

It really would be easier to fix bcl2fastq. Did I mention that?

-- After meeting on 16th April the decision is:

1) Ask Illumina about this feature
2) Proposed workaround (for variable-length barcodes) is as follows...
    - Ask Dan to add UDFs for I7 and I5 index read lengths
    - All short barcodes (8+8,6,8,...) will be replaced by the longer sequences as above,
      but the LIMS will not actually know the 'real' length.
    - The SSG will use the UDFs and trim any longer barcodes, so it's up to the lab to
      determine the correct number of cycles. If the number is set too short then this should
      be picked up as the collision check on the trimmed barcodes will fail

So that's the plan.

